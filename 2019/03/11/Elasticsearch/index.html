<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ElasticSearch,">










<meta name="description" content="ElasticSearch讲解说明，推荐《从Lucene到ElasticSearch全文检索实战》一书一起观看学习">
<meta name="keywords" content="ElasticSearch">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch">
<meta property="og:url" content="http://yoursite.com/2019/03/11/Elasticsearch/index.html">
<meta property="og:site_name" content="DeepRedApple">
<meta property="og:description" content="ElasticSearch讲解说明，推荐《从Lucene到ElasticSearch全文检索实战》一书一起观看学习">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-11T14:41:12.100Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Elasticsearch">
<meta name="twitter:description" content="ElasticSearch讲解说明，推荐《从Lucene到ElasticSearch全文检索实战》一书一起观看学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/11/Elasticsearch/">





  <title>Elasticsearch | DeepRedApple</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DeepRedApple</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/Elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DeepRedApple">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DeepRedApple">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Elasticsearch</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-11T22:18:50+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/11/Elasticsearch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/11/Elasticsearch/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>ElasticSearch讲解说明，推荐《从Lucene到ElasticSearch全文检索实战》一书一起观看学习</p>
</blockquote>
<a id="more"></a>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="ElasticSearch入门"><a href="#ElasticSearch入门" class="headerlink" title="ElasticSearch入门"></a>ElasticSearch入门</h2><h3 id="文档Document"><a href="#文档Document" class="headerlink" title="文档Document"></a>文档Document</h3><blockquote>
<p>用户存储在es中的数据文档，是es存储数据的最小的一个单元。类似于关系型数据表中的一行数据。</p>
<p>每一个文档都有一个唯一的id标识：自行指定、es自动生成</p>
</blockquote>
<p>Json Object，由字段(Field)组成，常见的数据类型如下:</p>
<ul>
<li>字符串：text(分词)、keyword(不分词)</li>
<li>数字型：long、integer、short、byte、double、float、half_float、scaled_float</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>二进制：binary</li>
<li>范围类型：integer_range、float_range、long_range、double_range、date_range</li>
</ul>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><blockquote>
<p>用于标注文档的相关信息</p>
</blockquote>
<ul>
<li>_index：文档所在的索引名</li>
<li>_type：文档所在的类型名</li>
<li>_id：文档唯一id</li>
<li>_uid：组合id，由_type和_id组成（6.x_type不再起作用，同_id一样）</li>
<li>_source：文档的原始Json数据，可以从这个获取每一个字段的内容</li>
<li>_all：整合所有字段的内容到该字段，默认禁用</li>
</ul>
<h3 id="索引Index"><a href="#索引Index" class="headerlink" title="索引Index"></a>索引Index</h3><blockquote>
<p>由具有相同字段的文档列表组成。类似于关系型数据库中的表，6.0版本。</p>
</blockquote>
<p>索引中存储具有相同结构的文档(Document)。每个索引都有自己的mapping定义，用于定义字段名和类型</p>
<p>一个集群可以有多个索引。比如：</p>
<p>Nginx日志存储的时候可以按照日期每天生成一个索引存储</p>
<ul>
<li>nginx-log-2017-01-01</li>
<li>nginx-log-2017-01-02</li>
<li>nginx-log-2017-01-03</li>
</ul>
<h3 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h3><blockquote>
<p>一个ElasticSearch的运行实例，是集群的构成单元。</p>
</blockquote>
<h3 id="集群Cluster"><a href="#集群Cluster" class="headerlink" title="集群Cluster"></a>集群Cluster</h3><blockquote>
<p>由一个或多个节点组成，对外提供服务</p>
</blockquote>
<h3 id="Rest-API"><a href="#Rest-API" class="headerlink" title="Rest API"></a>Rest API</h3><blockquote>
<p>ElasticSearch集群对外提供RESTful API</p>
</blockquote>
<ul>
<li>REST  REpresentational State Transfer</li>
<li>URI指定资源，如Index、Document</li>
<li>Http Method指明资源操作类型，如GET、POST、PUT、DELTE等</li>
</ul>
<p>交互方式：</p>
<ol>
<li>Curl命令行</li>
<li>Kibana DevTools</li>
</ol>
<h3 id="索引API"><a href="#索引API" class="headerlink" title="索引API"></a>索引API</h3><blockquote>
<p>es有专门的Index API，用户创建、更新、删除索引配置等</p>
</blockquote>
<ul>
<li>PUT /test_index  —创建索引</li>
<li>GET _cat/indices  —查看索引</li>
<li>DELETE /test_index —删除索引</li>
<li>POST  /test_index/doc/1/_update —更新索引</li>
</ul>
<h3 id="文档Document-API"><a href="#文档Document-API" class="headerlink" title="文档Document API"></a>文档Document API</h3><blockquote>
<p>es有专门的Document API  /index/type/id</p>
</blockquote>
<ul>
<li>创建文档 <ul>
<li>指定ID：PUT /test_index/doc/1 {“username”:”alfred”,”age”:1} 创建文档时，如果索引不存在，es会自动创建index和type</li>
<li>不指定ID：POST /test_index/doc {“username”:”tom”,”age”:20} </li>
</ul>
</li>
<li>查询文档<ul>
<li>指定ID：GET /test_index/doc/1 </li>
<li>搜索所有文档：GET /test_indes/doc/_search  {“query”:{“term”:{“_id”:1}}}</li>
</ul>
</li>
<li>批量创建<ul>
<li>endpoint为_bulk  POST _pulk  action_tye:index、update、create、delete   {“index”:{“_index”:”test_index”,”_type”:”doc”,”_id”:”3”}}<br>{“username”:”LZH”,”age”:45}<br>{“delete”:{“_index”:”test_index”,”_type”:”doc”,”_id”:”gg0mF2UBL7MW6CurOJYJ”}}<br>{“update”:{“_index”:”test_index”,”_type”:”doc”,”_id”:1}}<br>{“doc”:{“age”:11}}</li>
</ul>
</li>
<li>批量查询<ul>
<li>endpoint为_mget GET _mget {“docs”:[{“_index”:”test_index”,”_type”:”doc”,”_id”:1},{“_index”:”test_index”,”_type”:”doc”,”_id”:2},]}</li>
</ul>
</li>
</ul>
<h2 id="倒排索引和分词"><a href="#倒排索引和分词" class="headerlink" title="倒排索引和分词"></a>倒排索引和分词</h2><blockquote>
<p>举例：在书中，目录页对应正排索引，索引页对应倒排索引</p>
<p>正排索引：可以通过文档的id到文档内容、单词（需要做分词处理）的关联关系</p>
<p>倒排索引：单词到文档id的关联关系</p>
</blockquote>
<h3 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h3><blockquote>
<p>文档ID到文档内容、单词的关联关系，类似于书的目录，类似如下表格，根据文档ID获取内容</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文档ID</th>
<th style="text-align:center">文档内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ElasticSearch是最流行的搜索引擎</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">php是世界上最好的语言</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">ElasticSearch搜索引擎是如何诞生的</td>
</tr>
</tbody>
</table>
</div>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><blockquote>
<p>单词到文档ID的关联关系，类似书的索引页，类似如下表格，分词是倒排索引的一个前提条件，只有将文档内容进行分词以后才能进行倒排索引</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th style="text-align:center">文档ID列表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ElasticSearch</td>
<td style="text-align:center">1、3</td>
</tr>
<tr>
<td style="text-align:center">流行</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">搜索引擎</td>
<td style="text-align:center">1、3</td>
</tr>
<tr>
<td style="text-align:center">php</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">世界</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">最好</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">如何</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">诞生</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>查询实例步骤</strong> </p>
<ol>
<li>通过倒排索引查询获得“搜索引擎”的对应的内容的ID有1和3</li>
<li>通过正排索引查询1和3，获取完整的内容</li>
<li>返回用户最终结果</li>
</ol>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><blockquote>
<p>倒排索引是搜索引擎的核心，主要包含有两个部分</p>
<ol>
<li>单词词表（Term Dictionary）：记录所有文档的单词，一般比较大；记录单词到倒排列表的关联信息。采用的数据结构是B+ Tree</li>
<li>倒排列表（Posting List）：记录单词对应的文档集合，由倒排索引项（Posting）组成。倒排索引项（Posting）主要包含的信息有：<ol>
<li>文档ID，用于获取原始信息</li>
<li>单词频率（TF，Term Frequency），记录该单词在该文档中出现的次数，用于后续相关性算分</li>
<li>位置（Position），记录单词在文档中的分词位置（多个），用于做词语搜索（Phrase Query）</li>
<li>偏移（Offset），记录单词在文档的开始和结束位置，用于做高亮显示</li>
</ol>
</li>
</ol>
<p>在es中，存储的是一个Json格式的文档，其中包含多个字段，每个字段都有自己的倒排索引</p>
</blockquote>
<p><strong>以“搜索引擎”为例</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文档ID</th>
<th style="text-align:center">文档内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ElasticSearch是最流行的搜索引擎</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">php是世界上最好的语言</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">搜索引擎是如何诞生的</td>
</tr>
</tbody>
</table>
</div>
<p><strong>倒排列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">DocId</th>
<th style="text-align:center">TF</th>
<th style="text-align:center">Position</th>
<th style="text-align:center">Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">\<18,22\></18,22\></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">\<0,4></0,4></td>
</tr>
</tbody>
</table>
</div>
<h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><blockquote>
<p>分词是指将文本转换为一系列单词（term or token）的过程，也可以叫做文本分析，在es里面称为Analysis</p>
</blockquote>
<h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><blockquote>
<p>分词器是es中专门处理分词的组件，英文为Analyzer，它的组成如下：</p>
<ul>
<li>Character Filters<ul>
<li>针对原始文本进行处理，比如去除HTML特殊标记</li>
</ul>
</li>
<li>Tokenizer<ul>
<li>将原始文本按照一定规则分为单词</li>
</ul>
</li>
<li>Token Filters<ul>
<li>针对tokenizer处理的单词再加工，比如转小写、删除或新增等处理</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>预定义的分词器</strong></p>
<ul>
<li>Standard：Standard Analyzer<ul>
<li>默认分词器</li>
<li>其组成由{Tokenizer：Standard，Token Filters：Standard、Lower case、Stop(disabled by default)}。特性为：<ul>
<li>按词切分，支持多语言</li>
<li>小写处理</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone 分词后为[the,2,quick,brown,foxes,jumped,over,the,lazy,dog’s,bone]</li>
</ul>
</li>
<li>Simple：Simple Analyzer <ul>
<li>其组成由{Tokenizer：Lower Case}。特性为：<ul>
<li>按照非字母切分</li>
<li>小写处理</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone 分词后为[the,quick,brown,foxes,jumped,over,the,lazy,dog,s,bone]</li>
</ul>
</li>
<li>Whitespace：Whitespace Analyzer<ul>
<li>其组成由{Tokenizer：Whitespace}。特性为：<ul>
<li>按照空格切分</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone  分词后为[The,2,QUICK,Brown-Foxes,jumped,over,the,lazy,dog’s,bone]</li>
</ul>
</li>
<li>Stop：Stop Analyzer<ul>
<li>Stop Word指语气助词等修饰性的词语，比如the、an、的、这等等</li>
<li>其组成由{Tokenizer：Lower Case，Token Filter：Stop}。特性为<ul>
<li>相比Simple Analyzer多了Stop Word处理</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone 分词后为[quick,brown,foxes,jumped,over,lazy,dog,s,bone]</li>
</ul>
</li>
<li>Keyword：Keyword Analyzer<ul>
<li>其组成由[Tokenizer：Keyword]。特性为：<ul>
<li>不分词，直接将输入作为一个单词输出</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone 分词后为 [The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone]</li>
</ul>
</li>
<li>Pattern：Pattern Analyzer<ul>
<li>其组成由{Tokenizer：Pattern,Token Filters：Lower case、Stop(disabled by default)}。特性为：<ul>
<li>通过正则表达式自定义分隔符</li>
<li>默认是\W+，即非字词的符号作为分隔符</li>
</ul>
</li>
<li>示例：The 2 QUICK Brown-Foxes jumed over the lazy dog’s bone 分词后为 [the,2,quick,brown,foxes,jumped,over,the,lazy,god,s,bone]</li>
</ul>
</li>
<li>Language：Language Analyzer<ul>
<li>提供了30+常见语言的分词器</li>
</ul>
</li>
</ul>
<p><strong>中文分词</strong></p>
<blockquote>
<p>中文分词指的是将一个汉字序列切分成一个一个的单独的词。在英文中，单词之间是以空格作为自然分界符，汉语中词没有一个形式上的分界符</p>
</blockquote>
<ul>
<li>IK<ul>
<li>实现中英文单词的切分，支持ik_smart、ik_maxword等模式</li>
<li>可自定义词库，支持热更新分词词典</li>
<li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></li>
</ul>
</li>
<li>jieba<ul>
<li>python中最流行的分词系统，支持分词和词性标注</li>
<li>支持繁体分词、自定义词典、并行分词等</li>
<li><a href="http://github.com/singlee/elasticsearch-jieba-plugin" target="_blank" rel="noopener">http://github.com/singlee/elasticsearch-jieba-plugin</a></li>
</ul>
</li>
<li>基于自然语言处理的分词系统<ul>
<li>Hanlp<ul>
<li>由一些列模型与算法组成的Java工具包，目标是普及自然语言处理在生产环境中的应用</li>
<li><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener">https://github.com/hankcs/HanLP</a></li>
</ul>
</li>
<li>THULAC <ul>
<li>THU Lexical Analyzer for Chinese，由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，具有中文分词和词性标注功能</li>
<li><a href="https://github.com/microbun/elasticsearch-thulac-plugin" target="_blank" rel="noopener">https://github.com/microbun/elasticsearch-thulac-plugin</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h4><blockquote>
<p>当自带的分词无法满足需求时，可以自定义分词。通过自定义Character Filter、Tokenizer和Token Filter实现</p>
</blockquote>
<h5 id="Character-Filter"><a href="#Character-Filter" class="headerlink" title="Character Filter"></a>Character Filter</h5><ul>
<li>在Tokenizer之前对原始文本进行处理，比如增加、删除或替换字符等</li>
<li>自带的如下：<ul>
<li>HTML Strip去除html标签和转换html实体</li>
<li>Mapping进行字符替换操作</li>
<li>Pattern Replace进行正则匹配替换</li>
</ul>
</li>
<li>会影响后续tokenizer解析的position和offset信息</li>
<li>示例：POST _analyze {“tokenizer”:”keyword”,”char_filter”:[“html_strip”],”text”:”\<p>I&apos;m so \<b>happy\</b>!\</p>“} </li>
</ul>
<h5 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h5><ul>
<li>将原始文本按照一定规则切分为单词（term or token）</li>
<li>自带的如下：<ul>
<li>standard 按照单词进行分割</li>
<li>letter 按照非字符类进行分割</li>
<li>whitespace 按照空格进行分割</li>
<li>UAX URL Email 按照standard分割，但不会分割邮箱和url</li>
<li>NGram和Edge NGram连词分割</li>
<li>Path Hierarchy 按照文件路径进行切割</li>
</ul>
</li>
<li>示例：POST _analyze {“tokenizer”:”path_hierarchy”,”text”:”/one/two/three”}  #按照文件路径分割</li>
</ul>
<h5 id="Token-Filter"><a href="#Token-Filter" class="headerlink" title="Token Filter"></a>Token Filter</h5><ul>
<li>对于tokenizer输出的单词（term）进行增加、删除、修改等操作</li>
<li>自带的如下：<ul>
<li>lowercase 将所有term转换为小写</li>
<li>stop 删除stop words</li>
<li>NGram和Edge NGram连词分割</li>
<li>Synonym添加近义词term</li>
</ul>
</li>
<li>示例：POST _analyze {“text”:”a Hello,World!”,”tokenizer”:”standard”,”filter”:[“stop”,”lowercase”,{“type”:”ngram”,”min_gram”:2,”max_gram”:4}]} #min_gram 最小连词，max_gram最大连词</li>
</ul>
<h5 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h5><ul>
<li>自定义分词需要在索引的配置中设定 <strong>需要在index没有创建之前配置分词器</strong><ul>
<li>PUT test_index {“settings”:{“analysis”:{“char_filter”:{},”tokenizer”:{},”filter”:{},”analyzer”:{}}}}</li>
</ul>
</li>
<li>示例：PUT test_index_1 {“settings”:{“analysis”:{“analyzer”:{“my_custome_analyzer”:{“type”:”custom”,”tokenizer”:”standard”,”char_filter”:[“html_strip”],”filter”:[“lowercase”,”asciifolding”]}}}}}</li>
<li>示例：PUT test_index_2 {“settings”:{“analysis”:{“analyzer”:{“my_custom_analyzer”:{“type”:”custom”,”char_filter”:[“emoticons”],”tokenizer”:”punctuation”,”filter”:[“lowercase”,”englist_stop”]}},”tokenizer”:{“punctuation”:{“type”:”pattern”,”pattern”:”[  .,!?]”}},”char_filter”:{“emoticons”:{“type”:”mapping”,”mappings”:[“:)=&gt;_happy_“,”:(=&gt;_sad_“]}},”filter”:{“englist_stop”:{“type”:”stop”,”stopwords”:”_english”}}}}}</li>
</ul>
<h4 id="分词使用说明"><a href="#分词使用说明" class="headerlink" title="分词使用说明"></a>分词使用说明</h4><ul>
<li>创建或更新文档时（Index Time），会对相应的文档进行分词处理<ul>
<li>索引时分词是通过配置Index Mapping中每个字段的analyzer属性实现的，示例：PUT test_index {“mappings”:{“doc”:{“properties”:{“title”:{“type”:”text”,”analyzer”:”whitespace”}}}}} #指定分词器</li>
<li>不指定分词器时，使用默认standard</li>
</ul>
</li>
<li>查询时（Search Time），会对查询语句进行分词<ul>
<li>查询的时候通过analyzer指定分词器<ul>
<li>示例：POST test_index/_search  {“query”:{“match”:{“message”:{“query”:”hello”,”analyzer”:”standard”}}}}</li>
</ul>
</li>
<li>通过index mapping设置search_analyzer实现<ul>
<li>示例：PUT test_index  {“mappings”:{“doc”:{“properties”:{“title”:{“type”:”text”,”analyzer”:”whitespace”,”search_analyzer”:”standard”}}}}}</li>
</ul>
</li>
<li>一般不需要特别指定查询时分词器，直接使用索引时分词器即可，否则会出现无法匹配的情况</li>
</ul>
</li>
<li><strong>分词使用建议：</strong><ul>
<li>明确字段是否需要分词，不需要分词的字段就将type设置为keyword，可以节省空间和提高写性能</li>
<li>善用_analyze API，查看文档的具体分词结果</li>
<li>动手测试</li>
</ul>
</li>
</ul>
<p><strong>调用顺序</strong></p>
<div id="flowchart-0" class="flow-chart"></div>

<h3 id="Analyze-API"><a href="#Analyze-API" class="headerlink" title="Analyze API"></a>Analyze API</h3><blockquote>
<p>es提供了一个测试分词的api接口，方便验证分词效果，endpoint是_analyze</p>
<ul>
<li>可以直接指定analyzer进行测试</li>
<li>可以直接指定索引中的字段进行测试</li>
<li>可以自定义分词器进行测试</li>
</ul>
<p>输入关键词，结果不是理想中结果是，可以使用这个进行排查</p>
</blockquote>
<ul>
<li>直接指定analyzer进行分词 <ul>
<li>GET  _analyze {“analyzer”:”standard”,”text”:”hello world”} 结果中有分词结果、起始偏移、结束偏移、分词位置信息</li>
</ul>
</li>
<li>直接指定索引中的字段进行测试<ul>
<li>GET test_index/_analyze  {“field”:”username”, “text”:”hello world”}</li>
</ul>
</li>
<li>自定义分词器进行测试 <ul>
<li>POST _analyze {“tokenizer”:”standard”,”filter”:[“lowercase”],”text”:”Hello World!”}</li>
</ul>
</li>
</ul>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><blockquote>
<p>类似数据库中的表结果定义，主要作用如下：</p>
<ul>
<li>定义Index下的字段名（Field Name）</li>
<li>定义字段类型，比如数值型、字符串型、布尔型等</li>
<li>定义倒排索引相关的配置，比如是否索引、记录position等</li>
</ul>
</blockquote>
<h3 id="自定义Mapping"><a href="#自定义Mapping" class="headerlink" title="自定义Mapping"></a>自定义Mapping</h3><p>API：PUT my_index {“mappings”:{“doc”:{“properties”:{“title”:{“type”:”text”},”name”:{“type”:”keyword”},”age”:{“type”:”integer”}}}}} </p>
<ul>
<li>Mapping中的字段类型一旦设定后，禁止直接修改<ul>
<li>Lucene实现的倒排索引生成后不允许修改</li>
</ul>
</li>
<li>重新建立新的索引，然后做reindex操作</li>
<li>允许新增字段</li>
<li>通过dynamic参数来控制字段的新增<ul>
<li>true（默认）允许新增字段</li>
<li>false不允许自动新增字段，但是文档可以正常写入，但无法对字段进行查询等操作</li>
<li>strict文档不能写入，报错。要求非常严格</li>
</ul>
</li>
</ul>
<p><strong>参数说明</strong></p>
<ul>
<li>copy_to<ul>
<li>将该字段的值复制到目标字段，实现类似_all的作用</li>
<li>不会出现在_source中，只用来搜索</li>
</ul>
</li>
<li>index：字段不需要查询，比如敏感信息设置为false，不能被搜索<ul>
<li>控制当前字段是否索引，默认为true，即记录索引，false不记录，即不可搜索</li>
</ul>
</li>
<li>index_options：用于控制倒排索引记录的内容，有如下4中配置<ul>
<li>docs只记录doc id</li>
<li>freqs记录doc id和term frequencies</li>
<li>positions记录doc id、term frequencies和term position</li>
<li>offsets记录doc id、term frequencies、term position和character offsets</li>
<li>text类型默认配置为positions，其他默认为docs</li>
<li>记录内容越多，占用空间越大</li>
</ul>
</li>
<li>null_value<ul>
<li>当字段遇到null值时的处理策略，默认为null，即空值，此时es会忽略该值。可以通过设定该值设定字段的默认值</li>
</ul>
</li>
</ul>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><blockquote>
<p>自定义Mapping的操作步骤如下：</p>
</blockquote>
<ol>
<li>写入一条文档到es的临时索引中，获取es自动生成的mapping</li>
<li>修改步骤1得到的mapping，自定义相关配置</li>
<li>使用步骤2的mapping创建实际所需索引</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>核心数据类型<ul>
<li>字符串型text（分词）、keyword（不分词）</li>
<li>数值型long、integer、short、byte、double、float、half_float、scaled_float</li>
<li>日期类型date</li>
<li>布尔类型boolean</li>
<li>二进制类型binary</li>
<li>范围类型integer_range、float_range、long_range、double_range、date_range</li>
</ul>
</li>
<li>复杂数据类型<ul>
<li>数据类型array</li>
<li>对象类型json object</li>
<li>嵌套类型nested object</li>
</ul>
</li>
<li>地理位置数据类型<ul>
<li>geo_option</li>
<li>geo_shape</li>
</ul>
</li>
<li>专用类型<ul>
<li>记录IP地址</li>
<li>实现自动补全completion</li>
<li>记录分词数token_count</li>
<li>记录字符串hash值</li>
<li>percolator</li>
<li>join</li>
</ul>
</li>
</ul>
<p><strong>多字段特性multi-fields</strong></p>
<blockquote>
<p>允许对同一个字段采用不同的配置，比如分词，常见的例子如对人名实现拼音搜索，只需要在人名中新增一个子字段为pinyin即可</p>
</blockquote>
<h3 id="Dynamic-Mapping"><a href="#Dynamic-Mapping" class="headerlink" title="Dynamic Mapping"></a>Dynamic Mapping</h3><blockquote>
<p>es可以自动识别文档字段类型，从而降低用户使用成本</p>
<p>es是依靠JSON文档的字段类型来实现自动识别字段类型，支持的类型如下：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">JSON类型</th>
<th style="text-align:center">es类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">忽略</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">浮点类型</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">整数</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">object</td>
<td style="text-align:center">object</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">由第一个非null值的类型决定</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">匹配为日期则设定为date类型（默认开启）；匹配为数字的话设为float或long类型（默认关闭）；设为text类型，并且附带keyword的子字段</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong> PUT /my_index/doc/1                                          {“username”:”alfred”,”age”:14,”birth”:”1988-10-10”,”married”:false,”year”:”18”,”tags”:[“boy”,”fashion”],”money”:”100.1”}</p>
<h4 id="日期与数字识别"><a href="#日期与数字识别" class="headerlink" title="日期与数字识别"></a>日期与数字识别</h4><ul>
<li>日期的自动识别可以自行配置日期格式，以满足各种需求<ul>
<li>默认是[“strict_date_optional_time”,”yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z”]</li>
<li>strict_date_optional_time 是ISO datetime的格式，完整格式类型类似下面：<ul>
<li>YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)</li>
</ul>
</li>
<li>dynamic_date_formats 可以自定义日期类型  PUT my_index  {“mappings”:{“my_type”:{“dynamic_date_formats”:[“yyyy-MM-dd”]}}}</li>
<li>date_detection可以关闭日期自动识别的机制  PUT my_index  {“mappings”:{“my_type”:{“date_detection”:false}}}</li>
</ul>
</li>
<li>字符串是数字时，默认不会自动识别为整型，因为字符串中出现数字时完全合理的<ul>
<li>numeric_detection 可以开启字符串中数字的自动识别 PUT my_index  {“mappings”:{“my_type”:{“numeric_detection “:true}}}</li>
</ul>
</li>
</ul>
<h3 id="Dynamic-Templates"><a href="#Dynamic-Templates" class="headerlink" title="Dynamic Templates"></a>Dynamic Templates</h3><ul>
<li>允许根据es自动识别的数据类型、字段名等来动态设定字段类型，可以实现如下效果<ul>
<li>所有字符串类型都设定为keyword类型，即默认不分词。如果分词，比较占用内存空间</li>
<li>所有以message开头的字段都设定为text类型， 即分词</li>
<li>所有以long_开头的字段都设定为long类型</li>
<li>所有自动匹配为double类型的都设定为float类型，以节省空间</li>
</ul>
</li>
<li>Dynamic Templates API<ul>
<li>匹配规则一般有如下几个参数：<ul>
<li>match_mapping_type匹配es自动识别的字段类型，如boolean、long、string等</li>
<li>match，unmatch匹配字段名 以什么开头的进行匹配</li>
<li>path_match、path_unmatch匹配路径 对象内部的字段</li>
</ul>
</li>
<li>示例：PUT my_index  {“mappings”:{“doc”:{“dynamic_templates”:[{“strings”:{“match_mapping_type”:”string”,”mapping”:{“type”:”keyword”}}}]}}}</li>
</ul>
</li>
</ul>
<h3 id="索引模版"><a href="#索引模版" class="headerlink" title="索引模版"></a>索引模版</h3><p> 索引模版，英文为Index Template，主要用于在新建索引时自动应用预先设定的配置，简化索引创建的操作步骤</p>
<ul>
<li>可以设定索引的配置和mapping</li>
<li>可以有多个模版，根据order设置，order大的覆盖小的配置</li>
</ul>
<p><strong>索引模版API</strong>，endpoint为_temlate</p>
<p>示例：PUT _template/test_template  {“index_patterns”:[“te*”,”bar”],”order”:0,”settings”:{“number_of_shards”:1},”mappings”:{“doc”:{“_source”:{“enabled”:false},”properties”:{“name”:{“type”:”keyword”}}}}}</p>
<h2 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h2><blockquote>
<p>实现对es中存储的数据进行查询分析，endpoint为_search</p>
</blockquote>
<ul>
<li>查询主要有两种形式<ul>
<li>URI Search<ul>
<li>操作简便，方便通过命令行测试</li>
<li>仅包含部分查询语法</li>
</ul>
</li>
<li>Request Body Search<ul>
<li>es提供的完备查询语法Query DSL(Domain Specific Language)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="URI-Search"><a href="#URI-Search" class="headerlink" title="URI Search"></a>URI Search</h3><ul>
<li>通过uri query参数来实现搜索，常用的参数如下：<ul>
<li>q指定查询的语句，语法为Query String Syntax</li>
<li>df q参数中不指定字段时默认查询的字段， 如果不指定，es会查询所有字段</li>
<li>sort排序</li>
<li>timeout指定超时时间，默认不超时</li>
<li>from、size用户分页</li>
</ul>
</li>
</ul>
<h4 id="Query-String-Syntax"><a href="#Query-String-Syntax" class="headerlink" title="Query String Syntax"></a>Query String Syntax</h4><ul>
<li>term（单词）与phrase（词语）<ul>
<li>alfred way 等效于alfred OR way </li>
<li>“alfred way”词语查询，要求先后顺序</li>
</ul>
</li>
<li>泛查询（不指定字段的查询）<ul>
<li>alfred等效于在所有字段中去匹配term（前提条件，没有指定df 参数）</li>
</ul>
</li>
<li>指定字段<ul>
<li>name:alfred</li>
</ul>
</li>
<li>Group 分组设定，使用括号指定匹配的规则，<ul>
<li>(quick OR brown) AND fox 括号匹配优先级</li>
<li>status:(active OR pending) title:(full text search) 关键词作为一个整体</li>
</ul>
</li>
<li>布尔操作符<ul>
<li>AND(&amp;&amp;),OR(||),NOT(!)<ul>
<li>name:(tom NOT lee)</li>
<li>注意大写，不能小写</li>
</ul>
</li>
<li>+ - 分别对应must和must_not<ul>
<li>name:(tom +lee -alfred)</li>
<li>name:((lee &amp;&amp; !alfred) || (tom &amp;&amp; lee &amp;&amp; !alfred))</li>
<li>+在URL中会被解析为空格，要是用encode后结果才可以，为%2B</li>
</ul>
</li>
</ul>
</li>
<li>范围查询，支持数值和日期<ul>
<li>区间写法，闭区间用[]，开区间用{}<ul>
<li>age:[1 TO 10]       1&lt;=age&lt;=10</li>
<li>age:[1 TO 10}       1&lt;=age&lt;10</li>
<li>age:[1 TO     ]        age&gt;=1</li>
<li>age:[* TO 10]        age&lt;=10</li>
</ul>
</li>
<li>算数符号写法<ul>
<li>age:&gt;=1</li>
<li>age:(&gt;= 1 &amp;&amp; &lt;= 10)  或者 age:(+&gt;=1 +&lt;=10)</li>
</ul>
</li>
</ul>
</li>
<li>通配符查询<ul>
<li>？ 代表1个字符，*代表0或多个字符<ul>
<li>name:t?m</li>
<li>name:tom*</li>
<li>name:t*m</li>
</ul>
</li>
<li>通配符匹配执行效率低，且占用较多内存，不建议使用</li>
<li>如无特殊需求，不要将?/*放在最前面</li>
</ul>
</li>
<li>正则表达式匹配<ul>
<li>name:/[mb]oat/</li>
</ul>
</li>
<li>模糊匹配 fuzzy query<ul>
<li>name:roam~1</li>
<li>匹配与roam差1个character的词，比如foam、roams等</li>
</ul>
</li>
<li>近似度查询proximity search<ul>
<li>“fox quick”~5</li>
<li>以term为单位进行差异比较，比如”quick fox”,”quick brown fox” 都会被匹配</li>
</ul>
</li>
</ul>
<h3 id="Request-Body-Search"><a href="#Request-Body-Search" class="headerlink" title="Request Body Search"></a>Request Body Search</h3><p> 将查询语句通过http request body 发送到es，主要包含如下参数</p>
<ul>
<li>query 符合Query DSL语法的查询语句</li>
<li>from、size</li>
<li>timeout</li>
<li>sort</li>
<li>….</li>
</ul>
<h4 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h4><p> 基于JSON定义的查询语言，主要包含如下两种类型：</p>
<ul>
<li>字段类查询<ul>
<li>如term,match,range等，只针对某一个字段进行查询</li>
</ul>
</li>
<li>复合查询<ul>
<li>如bool查询等，包含一个或多个字段类查询或者复合查询语句</li>
</ul>
</li>
</ul>
<h3 id="字段类查询"><a href="#字段类查询" class="headerlink" title="字段类查询"></a>字段类查询</h3><p> 字段类查询主要包括以下两类：</p>
<ul>
<li>全文匹配<ul>
<li>针对text类型的字段进行全文检索，会对查询语句先进行分词处理，如match,match_phrase等query类型</li>
</ul>
</li>
<li>单词匹配<ul>
<li>不会对查询语句做分词处理，直接去匹配字段的倒排索引，如term,terms,range等query类型</li>
</ul>
</li>
</ul>
<h4 id="Match-Query"><a href="#Match-Query" class="headerlink" title="Match Query"></a>Match Query</h4><ul>
<li>对字段做全文检索，最基本和常用的查询类型<ul>
<li>API示例： GET test_search_index/_search {“query”:{“match”:{“username”:”alfred way”}}}     #关键词:match,字段名:username,待查询的语句:alfred way </li>
</ul>
</li>
</ul>
<ul>
<li>通过operator参数可以控制单词间的匹配关系，可选项为or和and<ul>
<li>API示例： GET test_search_index/_search {“query”:{“match”:{“username”:{“query”:”alfred way”,”operator”:”and”}}}}    #字段名:username,待查询的语句:alfred way,关键字:operator</li>
</ul>
</li>
<li>通过minimun_should_match参数可以控制需要匹配的单词数<ul>
<li>API示例：GET test_search_index/_search {“query”:{“match”:{“username”:{“query”:”alfred way”,”minimum_should_match”:2}}}}    #字段名:username,待查询的语句:alfred way,关键字:minimum_should_match</li>
</ul>
</li>
</ul>
<p><strong>Match Query流程</strong></p>
<div id="flowchart-1" class="flow-chart"></div>

<h5 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h5><ul>
<li>相关性算分是指文档与查询语句间的相关度，英文为relevance<ul>
<li>通过倒排索引可以获取与查询语句相匹配的文档列表</li>
<li>本质是一个排序问题，排序的依据是相关性算分</li>
</ul>
</li>
</ul>
<p><strong>倒排索引</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th style="text-align:center">文档ID列表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alfred</td>
<td style="text-align:center">1,2</td>
</tr>
<tr>
<td style="text-align:center">way</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><ul>
<li>Term Frequency(TF) 词频，即单词在该文档中出现的次数。词频越高，相关度越高</li>
<li>Document Frequency(DF) 文档频率，即单词出现的文档数</li>
<li>lnverse Document Frequency(IDF) 逆向文档频率，与文档频率相反，简单理解为1/DF。即单词出现的文档数越少，相关度越高</li>
<li>Field-length Norm 文档越短，相关性越高</li>
</ul>
<p><strong>模型</strong></p>
<ul>
<li><p>TF/IDF模型</p>
<ul>
<li><script type="math/tex; mode=display">
score(q,d)=coord(q,d)*queryNorm(q)*\sum_{t\ in\ q}(tf(t\ in\ d)*idf(t)^2*t.getBoost()*norm(t,d))</script></li>
<li><p>socre(q,d)：相关性得分，q为查询语句，d为匹配的文档。例如：q=”alfred” d=1,2</p>
</li>
<li><p>coord(q,d)和queryNorm(q)：对query进行正则化处理</p>
</li>
<li><p>在求和公式中，范围：t in q 查询语句分词之后的每一个term进行求和计算</p>
</li>
<li><p>tf(t in d)：词频计算</p>
</li>
<li><p>idf(t)^2：逆向文档频率计算</p>
</li>
<li><p>t.getBoost()：是否加权处理</p>
</li>
<li><p>norm(t,d)：Filed-length Norm计算</p>
</li>
<li><p>可以通过explain参数来查看具体的计算方法，但是要注意：</p>
<ul>
<li>es的算分是按照shard进行的，即shard的分数计算是相互独立的，所以在使用explain的时候注意分片数</li>
<li>可以通过设置索引的分片数为1来避免</li>
</ul>
</li>
</ul>
</li>
<li><p>BM25模型 5.x之后的默认模型 对TF/IDF的优化 </p>
</li>
</ul>
<h5 id="Match-Phrase-Query"><a href="#Match-Phrase-Query" class="headerlink" title="Match Phrase Query"></a>Match Phrase Query</h5><ul>
<li>对字段做检索，有顺序要求<ul>
<li>API示例： GET test_search_index/_search {“query”:{“match_phrase”:{“job”:”java engineer”}}}</li>
</ul>
</li>
<li>通过slop参数可以控制单词间的间隔<ul>
<li>API示例：GET test_search_index/_search  {“query”:{“match_phrase”:{“job”:{“query”:”java engineer”,”slop”:1}}}}  #运行java和engineer之间有一个距离的差距</li>
</ul>
</li>
</ul>
<h5 id="Query-String-Query"><a href="#Query-String-Query" class="headerlink" title="Query String Query"></a>Query String Query</h5><ul>
<li>类似于URI Search中q参数查询<ul>
<li>API示例：GET test_search_index/_search  {“query”:{“query_string”:{“default_field”:”username”,”query”:”alfred AND way”}}}</li>
<li>API示例：GET test_search_index/_search  {“query”:{“query_string”:{“fields”:[“username”,”job”],”query”:”alfred OR (java AND ruby)”}}}</li>
</ul>
</li>
</ul>
<h5 id="Simple-Query-String-Query"><a href="#Simple-Query-String-Query" class="headerlink" title="Simple Query String Query"></a>Simple Query String Query</h5><ul>
<li>类似Query String，但是会忽略错误的查询语法，并且仅支持部分查询语法</li>
<li>其常用的逻辑符号如下，不能使用AND、OR、NOT等关键词：<ul>
<li>+代指AND</li>
<li>|代指OR</li>
<li>- 代指NOT<ul>
<li>示例：GET test_search_index/_search  {“query”:{“simple_query_string”:{“query”:”alfred +way”,”fields”:[“username”]}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Term-Query"><a href="#Term-Query" class="headerlink" title="Term Query"></a>Term Query</h5><ul>
<li>将查询语句作为整个单词进行查询，即不对查询语句做分词处理。可以用来处理数字、布尔值、日期和文本。是一个精确值的查询方式<ul>
<li>API 示例：GET test_search_index/_search  {“query”:{“term”:{“username”:”alfred”}}}</li>
</ul>
</li>
</ul>
<h5 id="Terms-Query"><a href="#Terms-Query" class="headerlink" title="Terms Query"></a>Terms Query</h5><ul>
<li>一次传入多个单词进行查询，查找多个精确值。Term和Terms其实是包含的一个操作，并不是等于某个值<ul>
<li>API示例： GET test_search_index/_search  {“query”:{“terms”:{“username”:[“alfred”,”way”]}}}</li>
</ul>
</li>
</ul>
<h5 id="Range-Query"><a href="#Range-Query" class="headerlink" title="Range Query"></a>Range Query</h5><ul>
<li>范围查询主要针对数值和日期类型<ul>
<li>示例： GET test_search_index/_search  {“query”:{“range”:{“age”:{“gte”:10,”lte”:20}}}}</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">gt</td>
<td style="text-align:center">&gt;</td>
</tr>
<tr>
<td style="text-align:center">lt</td>
<td style="text-align:center">&lt;</td>
</tr>
<tr>
<td style="text-align:center">gte</td>
<td style="text-align:center">>=</td>
</tr>
<tr>
<td style="text-align:center">lte</td>
<td style="text-align:center">&lt;=</td>
</tr>
</tbody>
</table>
</div>
<h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4><ul>
<li>复合查询是指包含字段类查询或复合查询的类型，主要包括以下几类：<ul>
<li>constant_score query：该查询将其内部的查询结果文档得分都设定为1或者boost的值<ul>
<li>多用于结合bool查询实现自定义得分</li>
<li>示例：GET test_search_index/_search  {“query”:{“constant_score”:{“filter”:{“match”:{“username”:”alfred”}}}}}</li>
</ul>
</li>
<li>bool query</li>
<li>dis_max query</li>
<li>function_score query</li>
<li>boosting query</li>
</ul>
</li>
</ul>
<h5 id="Bool-query"><a href="#Bool-query" class="headerlink" title="Bool query"></a>Bool query</h5><ul>
<li>布尔查询由一个或多个布尔子句组成，主要包含如下四个。是一个组合过滤器</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">filter</th>
<th style="text-align:center">只过滤符合条件的文档，不计算相关性得分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">must</td>
<td style="text-align:center">文档必须符合must中的所有条件，会影响相关性得分，相当于and。必须匹配</td>
</tr>
<tr>
<td style="text-align:center">must_not</td>
<td style="text-align:center">文档必须不符合must_not中的所有条件，相当于not。不能匹配</td>
</tr>
<tr>
<td style="text-align:center">should</td>
<td style="text-align:center">文档可以符合should中的条件，会影响相关性得分，相当于or。至少有一个语句匹配</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>API示例： GET test_search_index/_search  {“query”:{“bool”:{“must”:[{}],”must_not”:[{}],”should”:[{}],”filter”:[{}]}}}</li>
</ul>
<h6 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h6><ul>
<li>Filter查询只过滤符合条件的文档，不会进行相关性算分<ul>
<li>es针对filter会有智能缓存，因此其执行效率很高</li>
<li>做简单匹配查询且不考虑算分时，推荐使用filter代替query等</li>
<li>API示例： GET test_search_index/_search  {“query”:{“bool”:{“filter”:[{“term”:{“username”:”alfred”}}]}}}</li>
</ul>
</li>
</ul>
<h6 id="Must"><a href="#Must" class="headerlink" title="Must"></a>Must</h6><ul>
<li>指包含的值</li>
<li>API示例： GET test_search_index/_search  {“query”:{“bool”:{“must”:[{“match”:{“username”:”alfred”}},{“match”:{“job”:”specialist”}}]}}}</li>
</ul>
<h6 id="Must-not"><a href="#Must-not" class="headerlink" title="Must not"></a>Must not</h6><ul>
<li>不包含的值</li>
<li>API示例： GET test_search_index/_search {“query”:{“bool”:{“must”:[{“match”:{“job”:”java”}}],”must_not”:[{“match”:{“job”:”ruby”}}]}}}</li>
</ul>
<h6 id="Should"><a href="#Should" class="headerlink" title="Should"></a>Should</h6><ul>
<li>should使用分两种情况<ul>
<li>bool查询中只包含should，不包含must查询<ul>
<li>文档必须满足至少一个条件<ul>
<li>minimum_should_match可以控制满足条件的个数或者百分比</li>
<li>API 示例：GET test_search_index/_search {“query”:{“bool”:{“should”:[{“term”:{“job”:”java”}},{“term”:{“job”:”ruby”}},{“term”:{“job”:”specialist”}}],”minimum_should_match”:2}}}</li>
</ul>
</li>
</ul>
</li>
<li>bool查询中同时包含should和must查询<ul>
<li>同时包含should和must时，文档不必满足should中的条件，但是如果满足条件，会增加相关性得分<ul>
<li>API示例：GET test_search_index/_search {“query”:{“bool”:{“must”:[{“term”:{“username”:”alfred”}}],”should”:[{“term”:{“job”:”ruby”}}]}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="Query-Context-VS-Filter-Context"><a href="#Query-Context-VS-Filter-Context" class="headerlink" title="Query Context VS Filter Context"></a>Query Context VS Filter Context</h6><ul>
<li>当衣蛾查询语句位于Query或者Filter上下文时，es执行的结果会不同</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">上下文类型</th>
<th style="text-align:center">执行类型</th>
<th style="text-align:center">使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Query</td>
<td style="text-align:center">查找与查询语句最匹配的文档，对所有文档进行相关性算分并排序</td>
<td style="text-align:center">query、bool中must和should</td>
</tr>
<tr>
<td style="text-align:center">Filter</td>
<td style="text-align:center">查找与查询语句相匹配的文档</td>
<td style="text-align:center">bool中的filter与must_not、const_score中的filter</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Count-API"><a href="#Count-API" class="headerlink" title="Count API"></a>Count API</h4><ul>
<li>获取符合条件的文档数，endpoint为_count<ul>
<li>API 示例： GET /test_search_index/_count {“query”:{“match”:{“username”:”alfred”}}}</li>
</ul>
</li>
</ul>
<h4 id="Source-Filtering"><a href="#Source-Filtering" class="headerlink" title="Source Filtering"></a>Source Filtering</h4><ul>
<li>过滤返回结果中_source中的字段，返回部分字段主要有如下几种方式：<ul>
<li>URI<ul>
<li>示例：GET test_search_index/_search?_source=username</li>
</ul>
</li>
<li>Request Body Search<ul>
<li>示例：GET test_search_index/_search  {“_source”:[“username”,”age”]}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式特性介绍"><a href="#分布式特性介绍" class="headerlink" title="分布式特性介绍"></a>分布式特性介绍</h2><ul>
<li>es支持集群模式，是一个分布式系统，其好处主要有两个：<ul>
<li>增大系统容量，如内存、磁盘，使得es集群可以支持PB级的数据</li>
<li>提高系统可用性，即使部分节点停止服务，整个集群依然可以正常服务</li>
</ul>
</li>
<li>es集群由多个es实例组成<ul>
<li>不同集群通过集群名字来区分，可通过cluster.name进行修改，默认为elasticsearch</li>
<li>每个es实例本质上是一个JVM进程，且有自己的名字，通过node.name进行修改</li>
</ul>
</li>
</ul>
<h3 id="cerebro安装与运行"><a href="#cerebro安装与运行" class="headerlink" title="cerebro安装与运行"></a>cerebro安装与运行</h3><ul>
<li>地址：<a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></li>
<li>bin/cerebro文件执行即可</li>
</ul>
<h3 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h3><ul>
<li>构建一个节点，node，cluster.name相同，node.name不同，端口不同</li>
<li>es集群相关的数据为cluster state，主要记录如下信息：<ul>
<li>节点信息，比如节点名称、连接地址等</li>
<li>索引信息，比如索引名称、配置等</li>
</ul>
</li>
</ul>
<p><strong>Master Node</strong></p>
<ul>
<li>可以修改cluster state的节点称为master节点，一个节点只能有一个</li>
<li>cluster state存储在每个节点上，master维护最新版本并同步给其他节点</li>
<li>master节点是通过集群中所有节点选举产生的，可以被选举的节点称为master-eligible节点。配置如下：<ul>
<li>node.master: true </li>
</ul>
</li>
</ul>
<p><strong>Coordinating Node</strong></p>
<ul>
<li>处理请求的节点即为coordinating节点，该节点为所有节点的默认角色，不能取消<ul>
<li>路由请求到正确的节点处理，比如创建索引的请求到master节点</li>
</ul>
</li>
</ul>
<p><strong>Data Node</strong></p>
<ul>
<li>存储数据的节点即为data节点，默认节点都是data类型，相关配置如下：<ul>
<li>node.data:true</li>
</ul>
</li>
</ul>
<p><strong>单点问题</strong></p>
<ul>
<li>如果一个集群中只有一个节点，这个节点停止，那么整个集群服务就停止。只能通过新增节点解决</li>
</ul>
<h3 id="副本与分片"><a href="#副本与分片" class="headerlink" title="副本与分片"></a>副本与分片</h3><h4 id="提高系统可用性"><a href="#提高系统可用性" class="headerlink" title="提高系统可用性"></a>提高系统可用性</h4><ul>
<li>服务可用性<ul>
<li>2个节点的情况下，允许其中1个节点停止服务</li>
</ul>
</li>
<li>数据可用性<ul>
<li>引入副本（Replication）解决</li>
<li>每个节点上都有完备的数据</li>
</ul>
</li>
</ul>
<h4 id="增大系统容量"><a href="#增大系统容量" class="headerlink" title="增大系统容量"></a>增大系统容量</h4><ul>
<li>将数据分布于所有的节点上，使用分片（Shard）</li>
<li>分片是es支持PB级数据的基石<ul>
<li>分片存储了部分数据，可以分布于任意节点上</li>
<li>分片数在索引创建时指定且后续不允许再更改，默认为5个</li>
<li>分片有主分片和副本分片之分，以实现数据的高可用</li>
<li>副本分片的数据由主分片同步，可以有多个，从而提高读取的吞吐量</li>
</ul>
</li>
</ul>
<h4 id="分片问题"><a href="#分片问题" class="headerlink" title="分片问题"></a>分片问题</h4><ul>
<li>通过新增节点不能提高已经分片的索引的数据容量，新增节点无法利用</li>
<li>通过新增副本不能提高已经有副本的索引的读取吞吐量</li>
<li>分片数的设定很重要，需要提前规划好<ul>
<li>过小会导致后续无法通过增加节点实现水平扩容</li>
<li>过大会导致一个节点上分布过多分片，造成资源浪费，同时会影响查询性能</li>
</ul>
</li>
</ul>
<h3 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h3><ul>
<li>通过如下api可以查看集群健康状态，包括以下三种：<ul>
<li>green健康状态，指所有主副分片都正常分配</li>
<li>yellow指所有主分片都正常分配，但是副本分片未正常分配</li>
<li>red有主分片未分片</li>
<li>API示例：GET _cluster/health</li>
</ul>
</li>
</ul>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ul>
<li>集群如有3个节点，此时集群状态是green</li>
<li>node1所在机器宕机导致服务终止<ul>
<li>1、node2和node3发现node1无法响应一段时间后会发起一个master选举，比如这里选择node2为master节点。此时由于主分片P0下线，集群状态变为red</li>
<li>2、node2发现主分片P0未分配，将R0提升为主分片，此时由于所有主分片都正常分配，集群状态变为yellow</li>
<li>3、node2为P0和P1生成新的副本，集群状态变为绿色</li>
</ul>
</li>
</ul>
<h3 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h3><ul>
<li>文档会最终存储到分片上<ul>
<li>例如：document1存储到node2节点的分片P1上</li>
<li>需要文档到分片的映射算法</li>
<li>目的是使得文档均匀分布到所有分片上，以充分利用资源</li>
<li>算法：随机选择或者round-robin算法，不可取，因为需要维护文档到分片的映射关系，成本巨大</li>
<li>根据文档值实时计算对应的分片</li>
</ul>
</li>
<li>文档到分片的映射算法<ul>
<li>shard = hash(routing) % number_of_primary_shards</li>
<li>hash算法保证可以将数据均匀地分散在分片中</li>
<li>routing是一个关键参数，默认是文档ID，也可以自行指定</li>
<li>number_of_primary_shards主分片数</li>
<li>该算法与主分片数相关，这也是分片数一点确定后便不能更改的原因</li>
</ul>
</li>
<li>文档创建流程<ol>
<li>Client向node3发起请求创建文档的请求</li>
<li>node3通过routing计算该文档应该存储在Shard1上，查询cluster state后确认主分片P1在node2上，然后转发创建文档的请求到node2</li>
<li>P1接收并执行创建文档的请求后，将同样的请求发送到副本分片R1上（R1在node1上）</li>
<li>R1接收并执行创建文档的请求后，通知P1成功的结果</li>
<li>P1接收副本分片结果后，通知node3创建成功</li>
<li>node3返回结果到Client</li>
</ol>
</li>
<li>文档读取流程<ol>
<li>Client向node3发起获取文档1的请求</li>
<li>node3通过routing计算该文档在Shard1上，查询cluster state后获取Shard1的主副分片列表，然后以轮询的机制获取一个shard，比如这是R1，然后转发读取文档的请求到node1</li>
<li>R1接收并执行读取文档请求后，将结果返回node3</li>
<li>node3返回结果给Client</li>
</ol>
</li>
<li>文档批量创建流程<ol>
<li>Client向node3发起批量创建文档的请求(bulk)</li>
<li>node3通过routing计算所有文档对应的shard，然后按照主shard分配对应执行的操作，同时发送请求到涉及的主shard，比如这个3个主shard都需要参与</li>
<li>主shard接收并执行请求后，将同样的请求同步到对应的副本shard</li>
<li>副本shard执行结果后返回结果到主shard，主shard再返回node3</li>
<li>node3整合结果后返回Client</li>
</ol>
</li>
<li>文档批量读取流程<ol>
<li>Client向node3发起批量获取文档的请求(mget)</li>
<li>node3通过routing计算所有文档对应的shard，然后以轮询的机制获取要参与shard，按照shard构建mget请求，同时发送请求到涉及的shard，比如这里有2个shard需要参与</li>
<li>R1、R2返回文档结果</li>
<li>node3返回结果给Client</li>
</ol>
</li>
</ul>
<h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><ul>
<li>脑裂问题，英文为split-brain，是分布式系统中的经典网络问题。<ul>
<li>示例：3个节点组成的集群，突然node1的网络和其他两个节点中断</li>
<li>node2与node3会重新选举master，比如node2成为了新的master，此时会更新cluster state</li>
<li>node1自己组成集群后，也会更新cluster state</li>
</ul>
</li>
<li>同一个集群有两个master，而且维护不同的cluster master，网络恢复后无法选择正确的master</li>
<li>解决方案为仅在可选举master-eligible节点数大于等于quorum时才进行master选举<ul>
<li>quorum = master - eligible节点数/2+1，例如3个master-eligible节点时，quorum为2</li>
<li>设定discovery.zen.minimun_master_nodes为quorum即可避免脑裂</li>
<li>在示例中，node1达不到选举的要求，则不参与选择；node2和node3可以进行选举，待网络恢复后，node1会加入到集群中</li>
</ul>
</li>
</ul>
<h3 id="Shard详解"><a href="#Shard详解" class="headerlink" title="Shard详解"></a>Shard详解</h3><ul>
<li>倒排索引的不可变更：倒排索引一旦生成，不能更改</li>
<li>其好处如下：<ul>
<li>不用考虑并发写文件的问题，杜绝了锁机制带来的性能问题</li>
<li>由于文件不再更改，可以充分利用文件系统缓存，只需载入一次，只要内存足够，对该文件的读取都会从内存读取，性能高</li>
<li>利于生成缓存数据</li>
<li>利于对文件进行压缩存储，节省磁盘和内存存储空间</li>
</ul>
</li>
<li>坏处：<ul>
<li>需要写入新文档时，必须重新构建倒排索引文件，然后替换老文件后，新文档才能被检索，导致文档实时性差</li>
</ul>
</li>
<li>文档搜索实时性<ul>
<li>解决方案是新文档直接生成新的倒排索引文件，查询的同时查询所有的倒排文件，然后做结果的汇总计算即可</li>
</ul>
</li>
<li>Lucene便是采用了这种方案，它构建的单个倒排索引称为segment，合在一起称为Index，与ES中的Index概念不同。ES中的一个Shard对应一个Lucene Index</li>
<li>Lucene会有一个专门的文件来记录所有的segment信息，称为commit point</li>
<li>文档搜索实时性-refresh<ul>
<li>segment写入磁盘的过程依然很耗时，可以借助文件系统缓存的特性，先将segment在缓存中创建并开放查询来进一步提升实时性，该过程在es中被称为refresh</li>
<li>在refresh之前文档会先存储在一个buffer（缓冲队列）中，refresh时将buffer中的所有文档清空并生成segment</li>
<li>es默认每1秒执行一次refresh，因此文档的实时性被提高到1秒，这也是es被称为近实时（Near Real TIme）的原因</li>
<li>refresh发生的时机主要有如下几种情况：<ul>
<li>间隔时间达到时，通过index.settings.refresh_interval来设定，默认是1秒</li>
<li>index.buffer占满时，其大小通过indices.memory.index_buffer_size设置，默认为jvm head的10%，所有shard共享</li>
<li>flush发生时也会发生reflush</li>
</ul>
</li>
</ul>
</li>
<li>文档搜索实时性-translog<ul>
<li>如果在内存中的segment还没有写入磁盘前发生了宕机，那么其中的文档就无法恢复了</li>
<li>es引入translog机制。写入文档到buffer时，同时将该操作写入translog。</li>
<li>translog文件会即时写入磁盘（fsync），6.x默认每个请求都会落盘，可以修改为每5秒写一次，这样风险便是5秒内的数据，相关配置index.translog.*</li>
<li>es启动时会检查translog文件，并从中恢复数据</li>
</ul>
</li>
<li>文档搜索实时性-flush<ul>
<li>flush负责将内存中的segment写入到磁盘，主要做如下的工作：<ul>
<li>将translog写入磁盘</li>
<li>将index buffer清空，其中的文档生成一个新的segment，相当于一个refresh操作</li>
<li>执行fsync操作，将内存中的segment写入磁盘</li>
<li>更新commit point并写入磁盘</li>
<li>删除旧的translog文件</li>
</ul>
</li>
<li>flush发生的时机主要有如下几种情况：<ul>
<li>间隔时间达到时，默认是30分钟，5.x之前可以通过index.translog.flush_threshold_period修改，之后无法修改</li>
<li>translog占满时，其大小可以通过index.translog.flush_threshold_size控制，默认是512mb，每个index有自己的translog</li>
</ul>
</li>
</ul>
</li>
<li>文档搜索实时性-删除与更新文档<ul>
<li>segment一旦生成，无法修改</li>
<li>删除操作：<ul>
<li>Lucene专门维护一个.del的文件，记录所有已经删除的文档，注意.del上记录的是文档在Lucene内部的ID</li>
<li>在查询结果返回前会过滤掉.del中的所有文档</li>
</ul>
</li>
<li>更新操作：<ul>
<li>首先删除文档，然后在创建新文档</li>
</ul>
</li>
</ul>
</li>
<li>Segment Merging<ul>
<li>随着segment的增多，由于一次查询的segment数增多，查询速度会变慢</li>
<li>es会定时在后台进行segment merge的操作，减少segment的数量</li>
<li>通过force_merge_api可以手动强制做segment merge的操作</li>
</ul>
</li>
</ul>
<h2 id="Search的运行机制"><a href="#Search的运行机制" class="headerlink" title="Search的运行机制"></a>Search的运行机制</h2><h3 id="Query-Then-Fetch"><a href="#Query-Then-Fetch" class="headerlink" title="Query Then Fetch"></a>Query Then Fetch</h3><ul>
<li>Search执行的时候实际分为两个步骤运行：<ul>
<li>Query阶段：node3在接收到用户的search请求后，会先进行Query阶段（此时是Coordinating Node角色）<ol>
<li>node3在6个主副分片中随机选择3个分片，发送search request</li>
<li>被选中的3个分片会分别执行查询并排序，返回from+size个文档Id和排序值</li>
<li>node3整合3个分片返回的from+size个文档Id，根据排序值排序后选取from到from+size的文档Id</li>
</ol>
</li>
<li>Fetch阶段：node3根据Query阶段获取的文档Id列表去对应的shard上获取文档详情数据<ol>
<li>node3向相关的分片发送multi_get请求</li>
<li>3个分片返回文档详细数据</li>
<li>node3拼接返回的结果并返回给客户</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="相关性算分-1"><a href="#相关性算分-1" class="headerlink" title="相关性算分"></a>相关性算分</h3><ul>
<li>相关性算分在shard与shard间是相互独立的，也就意味着同一个Term的IDF等值在不同shard上是不同的。文档的相关性算分和它所处的shard相关</li>
<li>在文档数量不多时，会导致相关性算分严重不准的情况发生</li>
<li>解决思路有两个：<ul>
<li>一是设置分片数为1个，从根本上解决问题，在文档数量不多的情况下可以考虑使用该方案，比如百万到千万级别的文档数量</li>
<li>二是使用DFS Query-then-Fetch查询方式<ul>
<li>DFS Query-then-Fetch是在拿到所有文档后再重新完整的计算一次相关性算分，耗费更多的CPU和内存，执行性能也比较低下，一般不建议使用。使用方式如下：</li>
<li>GET test_index/_search?search_type=dfs_query_then_fetch  {“query”:{“match”:{“name”:”hello”}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>es默认会采用相关性算分排序，用户可以通过设定sorting参数来自行设定排序规则</li>
<li>API示例：<ul>
<li>GET test_index/_search {“sort”:{“birth”:”desc”}}</li>
<li>GET test_index/_search {“sort”:[{“birth”:”desc”},{“_score”:”desc”},{“_doc”:”desc”}]}</li>
</ul>
</li>
<li>按照字符串排序比较特殊，因为es有text和keyword两种类型，针对text类型排序，按照如下API执行会报错：<ul>
<li>GET test_index/_search  {“sort”: {“username”: “desc”}}  因为text类型是可以进行分词的</li>
<li>解决方案是API如下示例</li>
<li>GET test_index/_search  {“sort”:{“username.keyword”:”desc”}}  即可，keyword是username的子字段的类型，是不分词的</li>
</ul>
</li>
<li>排序的过程实质是对字段原始内容排序的过程，这个过程中是倒排索引并不能发挥作用，需要使用到正排索引，也就是通过文档Id和字段可以快速得到字段原始内容</li>
<li>es对此提供了两种实现方式：<ul>
<li>fielddata默认禁止</li>
<li>doc values默认启用，除了text类型</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">FieldData</th>
<th style="text-align:center">DocValues</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建时机</td>
<td style="text-align:center">搜索时即时创建</td>
<td style="text-align:center">索引时创建，与倒排索引创建时机一致</td>
</tr>
<tr>
<td style="text-align:center">创建位置</td>
<td style="text-align:center">JVM Head</td>
<td style="text-align:center">磁盘</td>
</tr>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:center">不会占用额外的磁盘资源</td>
<td style="text-align:center">不会占用Heap内存</td>
</tr>
<tr>
<td style="text-align:center">确定</td>
<td style="text-align:center">文档过多时，即时创建会花过多时间，占用过多Heap内存</td>
<td style="text-align:center">减慢索引速度，占用额外的磁盘资源</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Fielddata"><a href="#Fielddata" class="headerlink" title="Fielddata"></a>Fielddata</h4><ul>
<li>Fielddata默认是关闭的，只是针对text类型的字段，可以通过如下API开启：<ul>
<li>此时字符串是按照分词后的Term排序，往往结果很难符合预期</li>
<li>一般是在分词进行聚合分析的时候开启。可以随时开启和关闭</li>
<li>API示例： PUT  test_index/_mapping/doc  {“properties”:{“username”:{“type”:”text”,”fielddata”:true}}}  可以随时开启和关闭</li>
</ul>
</li>
</ul>
<h4 id="Doc-Values"><a href="#Doc-Values" class="headerlink" title="Doc Values"></a>Doc Values</h4><ul>
<li>Doc Values默认是启动的，可以在创建索引的时候关闭：<ul>
<li>如果后面要再开启doc values，需要做reindex操作。当明确知道不需要使用这个字段进行排序和聚合分析，就可以把这个字段的doc_values设置为false。</li>
</ul>
</li>
</ul>
<h4 id="docvalues-fields"><a href="#docvalues-fields" class="headerlink" title="docvalues_fields"></a>docvalues_fields</h4><ul>
<li>可以通过该字段获取fielddata或者doc values中存储的内容    <ul>
<li>API示例：GET test_index/_search  {“docvalue_fields”: [“username”,”username.keyword”,”age”]} </li>
</ul>
</li>
</ul>
<h3 id="分页和遍历"><a href="#分页和遍历" class="headerlink" title="分页和遍历"></a>分页和遍历</h3><h4 id="from-size"><a href="#from-size" class="headerlink" title="from/size"></a>from/size</h4><ul>
<li>最常用的分页方案<ul>
<li>from 指明开始位置</li>
<li>size 指明获取总数</li>
<li>total_page=(total + page_size - 1) / page_size</li>
</ul>
</li>
<li>深度分页：在数据分片存储的情况下如何获取前1000个文档？<ul>
<li>获取从990~1000的文档时，会在每个分片上都先获取1000个文档，然后再由Coordinating Node聚合所有分片的结果后再排序获取前1000个文档</li>
<li>页数越深，处理文档越多，占用内存越多，耗时越长。尽量避免深度分页，es通过index.max_result_window限定最多到10000条数据</li>
<li>在每个节点上获取前1000条数据，然后再由Coordinating Node把（节点数 * 1000）条数据进行排序后返回990~1000的文档</li>
</ul>
</li>
</ul>
<h4 id="Scroll"><a href="#Scroll" class="headerlink" title="Scroll"></a>Scroll</h4><ul>
<li>遍历文档集的api，以快照的方式来避免深度分页的问题<ul>
<li>不能用来做实时搜索，因为数据不是实时的</li>
<li>尽量不要使用复杂的sort条件，使用_doc最高效</li>
<li>使用稍嫌复杂</li>
</ul>
</li>
<li>使用步骤：<ol>
<li>需要发起1个scroll search<ul>
<li>es在收到该请求后会根据查询条件创建文档Id合集的快照</li>
<li>API示例：GET test_search_index/_search?scroll=5m {“size”:1} 该scroll快照的有效时间为5分钟，size指的是每一次scroll返回的文档数，返回有_scroll_id下次调用使用</li>
</ul>
</li>
<li>调用scroll search的api，获取文档集合<ul>
<li>不断迭代调用直到返回hits.hits数组为空时停止，我在使用时发现可以不进行迭代调用，每次返回的scroll_id都是一样的</li>
<li>API示例：POST _search/scroll  {“scroll”:”5m”,”scroll_id”:”…..”}  返回有_scroll_id下次调用使用</li>
</ul>
</li>
</ol>
</li>
<li>过多的scroll调用会占用大量内存，可以通过clear api删除过多的scroll快照<ul>
<li>API 示例：DELETE /_search/scroll {“scroll_id”:[“….”,”….”]}</li>
</ul>
</li>
</ul>
<h4 id="Search-after"><a href="#Search-after" class="headerlink" title="Search_after"></a>Search_after</h4><ul>
<li>避免深度分页的性能问题，提供实时的下一页文档获取功能<ul>
<li>缺点是不能使用from参数，即不能指定页数</li>
<li>只能下一页，不能上一页</li>
<li>使用简单</li>
</ul>
</li>
<li>使用步骤：<ol>
<li>正常的搜索，但是要指定sort值，并保证值唯一</li>
<li>为使用上一步最后一个文档的sort值进行排序</li>
</ol>
</li>
<li>原理：通过唯一排序值定位将每次要处理的文档数都控制的size内<ul>
<li>先到每一个节点中获取排序的size个</li>
<li>再由Coordinating Node将总的文档进行排序后返回前size个文档</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">From/Size</td>
<td style="text-align:center">需要实时获取顶部的部分文档，且需要自由翻页</td>
</tr>
<tr>
<td style="text-align:center">Scroll</td>
<td style="text-align:center">需要全部文档，如导出所有数据的功能</td>
</tr>
<tr>
<td style="text-align:center">Search_after</td>
<td style="text-align:center">需要全部文档，不需要自由翻页</td>
</tr>
</tbody>
</table>
</div>
<h2 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h2><ul>
<li>聚合分析，英文为Aggregation，是es除了搜索功能外提供的针对es数据做统计分析的功能<ul>
<li>功能丰富，提供Bucket、Metric、Pipeline等多种分析方式，可以满足大部分的分析需求</li>
<li>实时性高，所有的计算结果都时即时返回的</li>
</ul>
</li>
<li>分类<ul>
<li>Bucket，分桶类型，类似SQL中的GROUP BY语法</li>
<li>Metric，指标分析类型，如计算最大值、最小值、平均值等</li>
<li>Pipeline，管道分析类型，基于上一级的聚合分析结果进行再分析</li>
<li>Matrix，矩阵分析类型</li>
</ul>
</li>
</ul>
<h3 id="Metric聚合分析"><a href="#Metric聚合分析" class="headerlink" title="Metric聚合分析"></a>Metric聚合分析</h3><ul>
<li>指标分析类型，如计算最大值、最小值、平均值等</li>
<li>分类：<ul>
<li>单值分析，只输出一个分析结果<ul>
<li>min、max、avg、sum<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“min_age”:{“min”:{“field”:”age”}}}}</li>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“max_age”:{“max”:{“field”:”age”}}}}</li>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“avg_age”:{“avg”:{“field”:”age”}}}}</li>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“sum_age”:{“sum”:{“field”:”age”}}}}</li>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“max_age”:{“max”:{“field”:”age”}},”min_age”:{“min”:{“field”:”age”}},”avg_age”:{“avg”:{“field”:”age”}},”sum_age”:{“sum”:{“field”:”age”}}}}</li>
</ul>
</li>
<li>cardinality：意为集合的势，或者基数，是指不同数值的个数，类似SQL中distinct count概念<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“count_of_job”:{“cardinality”:{“field”:”job.keyword”}}}}</li>
</ul>
</li>
</ul>
</li>
<li>多值分析，输出多个分析结果<ul>
<li>stats、extended stats<ul>
<li>stats：返回一系列数值类型的统计值，包含min、max、avg、sum和count<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“stats_age”:{“stats”:{“field”:”age”}}}}</li>
</ul>
</li>
<li>extended stats：对stats的扩展，包含了更多的统计数据，如方差、标准差等<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“stats_age”:{“extended_stats”:{“field”:”age”}}}}</li>
</ul>
</li>
</ul>
</li>
<li>percentile、percentile rank<ul>
<li>percentile：百分位数统计，查看百分比之内的统计<ul>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“per_age”:{“percentiles”:{“field”:”age”,”percents”:[1,20,25,50,75,95,99]}}}}</li>
</ul>
</li>
<li>percentile rank：百分位数排名统计<ul>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“per_age”:{“percentile_ranks”:{“field”:”age”,”values”:[20,15,25,28]}}}}</li>
</ul>
</li>
</ul>
</li>
<li>top hits<ul>
<li>一般用于分桶后获取该桶内最匹配的顶部文档列表，即详情数据</li>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“ages”:{“terms”:{“field”:”age”,”size”:2},”aggs”:{“top_age”:{“top_hits”:{“size”:2,”sort”:[{“age”:{“order”:”desc”}}]}}}}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Bucket聚合分析"><a href="#Bucket聚合分析" class="headerlink" title="Bucket聚合分析"></a>Bucket聚合分析</h3><ul>
<li>Bucket，意为桶，即按照一定的规则将文档分配到不同的桶中，达到分类分析的目的</li>
<li>按照Bucket的分桶策略，常见的Bucket聚合分析如下：<ul>
<li>Terms：该分桶策略最简单，直接按照term来分桶，如果是text类型，则按照分词后的结果分桶<ul>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”,”size”:4}}}}</li>
</ul>
</li>
<li>Range：通过指定数值范围来设定分桶规则<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“age_rang”:{“range”:{“field”:”age”,”ranges”:[{“to”:15},{“from”:15,”to”:20},{“from”:20,”to”:25},{“from”:25,”to”:30},{“from”:30}]}}}}</li>
</ul>
</li>
<li>Date Range：通过指定日期的范围来设定分桶规则<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“date_range”:{“range”:{“field”:”birth”,”format”:”yyyy”,”ranges”:[{“to”:”1980”},{“from”:”1980”,”to”:”1990”},{“from”:”1990”}]}}}}</li>
</ul>
</li>
<li>Histogram：直方图，以固定间隔的策略来分割数据<ul>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“age_hist”:{“histogram”:{“field”:”age”,”interval”:5,”extended_bounds”:{“min”:15,”max”:30}}}}}</li>
</ul>
</li>
<li>Date Histogram：日期直方图，以固定日期间隔的策略来分割数据<ul>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“birth_hist”:{“date_histogram”:{“field”:”birth”,”interval”:”year”,”format”:”yyyy”}}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Bucket-Metric聚合分析"><a href="#Bucket-Metric聚合分析" class="headerlink" title="Bucket + Metric聚合分析"></a>Bucket + Metric聚合分析</h3><ul>
<li>Bucket聚合分析允许通过添加子分析来进一步进行分析，该子分析可以是Bucket也可以是Metric。</li>
<li>分桶后再分桶<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”,”size”:10},”aggs”:{“age_range”:{“range”:{“field”:”age”,”ranges”:[{“to”:15},{“from”:15,”to”:20},{“from”:20,”to”:25},{“from”:25,”to”:30},{“from”:30}]}}}}}}</li>
</ul>
</li>
<li>分桶后进行数据分析<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”,”size”:10},”aggs”:{“age”:{“stats”:{“field”:”age”}}}}}}</li>
</ul>
</li>
</ul>
<h3 id="Pipeline聚合分析"><a href="#Pipeline聚合分析" class="headerlink" title="Pipeline聚合分析"></a>Pipeline聚合分析</h3><ul>
<li>针对聚合分析的结果再次进行聚合分析，而且支持链式调用</li>
<li>Pipeline的分析结果会输出到原结果中，根据输出位置的不同，分为两类：<ul>
<li>Parent结构内嵌到现有的聚合分析结果中<ul>
<li>Derivative 求导</li>
<li>Moving Average 移动平均值</li>
<li>Cumulative Sum 累加和</li>
</ul>
</li>
<li>Sibling结果与现有聚合分析结果同级<ul>
<li>Max/Min/Avg/Sum Bucket<ul>
<li>API 示例：GET test_search_index/_search  {“size”:0,”aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”,”size”:10},”aggs”:{“min_age”:{“min”:{“field”:”age”}}}},”job_min_age”:{“min_bucket”:{“buckets_path”:”jobs&gt;min_age”}}}}    查询年龄最小的那个人是什么工作</li>
</ul>
</li>
<li>Stats/Extended Stats Bucket</li>
<li>Percentiles Bucket</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><ul>
<li>es聚合分析默认作用范围是query的结果集，可以通过如下方式改变其作用范围：<ul>
<li>filter：只为某一个聚合分析设定过滤条件，从而在不更改整体query语句情况下修改了作用范围</li>
<li>post_filter：作用于文档过滤，但在聚合分析后生效<ul>
<li>API 示例： GET test_search_index/_search  {“aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”}}},”post_filter”:{“match”:{“job.keyword”:”java engineer”}}}</li>
</ul>
</li>
<li>global：无视query过滤条件，基于全部文档进行分析<ul>
<li>API 示例： GET test_search_index/_search  {“query”:{“match”:{“job”:”java”}},”aggs”:{“java_avg_age”:{“avg”:{“field”:”age”}},”all”:{“global”:{},”aggs”:{“avg_age”:{“avg”:{“field”:”age”}}}}}}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><ul>
<li>可以使用自带的关键数据进行排序，比如：_count文档数、_key按照key值排序</li>
<li>API 示例： GET test_search_index/_search  {“size”:0,”aggs”:{“jobs”:{“terms”:{“field”:”job.keyword”,”size”:10,”order”:[{“stats_age.sum”:”asc”}]},”aggs”:{“stats_age”:{“stats”:{“field”:”age”}}}}}}  按照stats_age.sum排序</li>
</ul>
<h3 id="原理和精准度问题"><a href="#原理和精准度问题" class="headerlink" title="原理和精准度问题"></a>原理和精准度问题</h3><ul>
<li>原理：在每一个节点中，根据聚合分析算出每个节点上的聚合结果；每一个节点上的聚合结果返回到Coordinating Node中，Coordinating Node再把每一个节点聚合返回的结果进行再次的聚合分析，得到结果；最后返回到Client。但是Terms并不永远准确</li>
<li>Terms不准确的原因：由于数据分散在多个Shard上，Coordinating Node无法得悉数据全貌</li>
<li>Terms不准确的解决方法：<ul>
<li>设置Shard数为1，消除数据分散的问题</li>
<li>合理设置Shard_Size大小，即每次从Shard上额外多获取数据，以提升准确度<ul>
<li>设定方法：terms聚合返回结果中有如下两个统计值<ul>
<li>doc_count_error_upper_bound：被遗漏的term可能的最大值</li>
<li>sum_other_doc_count：返回结果bucket的term外其他term的文档总数</li>
<li>设定show_term_doc_count_error:true可以查看每个bucket误算的最大值</li>
</ul>
</li>
<li>Shard_Size默认大小：shard_size = (size * 1.5) + 10</li>
<li>通过调整Shard_Size的大小降低doc_count_error_upper_bound来提升精度，减少了响应时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="近似统计算法"><a href="#近似统计算法" class="headerlink" title="近似统计算法"></a>近似统计算法</h3><ul>
<li>在ES的聚合分析中，Cardinality和Percentile分析使用的是近似统计算法<ul>
<li>结果是近似准确的，但不一定精准</li>
<li>可以通过参数的调整使其结果精准，但同时也意味着更多的计算的时间和更大的性能消耗</li>
</ul>
</li>
</ul>
<h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><ul>
<li>简介：英文为Data Modeling，为创建数据模型的过程</li>
<li>数据模型<ul>
<li>对现实世界进行抽象描述的一种工具和方法</li>
<li>通过抽象的实体以及实体之间的联系的形式去描述业务规则，从而实现对现实世界的映射</li>
</ul>
</li>
<li>数据建模过程：<ul>
<li>概念模型<ul>
<li>确定系统的核心需求和范围边界，设计实体与实体间的关系</li>
</ul>
</li>
<li>逻辑模型<ul>
<li>进一步梳理业务需求，确定每个实体的属性、关系和约束等</li>
</ul>
</li>
<li>物理模型<ul>
<li>结合具体的数据产品，在满足业务读写性能等需求的前提下确定最终的定义</li>
<li>MySQL、MongoDB、ElasticSearch等</li>
<li>第三范式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ES中的数据建模"><a href="#ES中的数据建模" class="headerlink" title="ES中的数据建模"></a>ES中的数据建模</h3><ul>
<li>ES是基于Lucene以倒排索引为基础实现的存储体系，不遵循关系型数据库中的范式约定</li>
<li>Mapping字段相关设置<ul>
<li>enabled<ul>
<li>true|false</li>
<li>仅存储，不做搜索或聚合分析</li>
</ul>
</li>
<li>index<ul>
<li>true|false</li>
<li>是否构建倒排索引</li>
</ul>
</li>
<li>index_options<ul>
<li>docs|freqs|positions|offsets</li>
<li>存储倒排索引的哪些信息</li>
</ul>
</li>
<li>norms<ul>
<li>true|false</li>
<li>是否存储归一化相关参数，如果字段仅用于过滤和局和分析，可关闭</li>
</ul>
</li>
<li>doc_values<ul>
<li>true|false</li>
<li>是否启动doc_values，用户排序和聚合分析</li>
</ul>
</li>
<li>field_data<ul>
<li>false|true</li>
<li>是否为text类型启动fielddata，实现排序和聚合分析</li>
</ul>
</li>
<li>store<ul>
<li>false|true</li>
<li>是否存储该字段值</li>
</ul>
</li>
<li>coerce<ul>
<li>true|false</li>
<li>是否开启自动数据类型转换功能，比如字符串转为数字、浮点转为整型等</li>
</ul>
</li>
<li>multifields多字段<ul>
<li>灵活使用多字段特性来解决多样的业务需求</li>
</ul>
</li>
<li>dynamic<ul>
<li>true|false|strict</li>
<li>控制mapping自动更新</li>
</ul>
</li>
<li>date_detection<ul>
<li>true|false</li>
<li>是否自动识别日期类型</li>
</ul>
</li>
</ul>
</li>
<li>Mapping字段属性的设定流程<ol>
<li>是何种类型？<ul>
<li>字符串类型<ul>
<li>需要分词则设定为text类型，否则设置为keyword类型</li>
</ul>
</li>
<li>枚举类型<ul>
<li>基于性能考虑将其设定为keyword类型， 即便该数据为整型</li>
</ul>
</li>
<li>数值类型<ul>
<li>尽量选择贴近的类型，比如byte即可表示所有数值时，即选用byte，不要用long</li>
</ul>
</li>
<li>其他类型<ul>
<li>比如布尔类型、日期、地理位置数据等</li>
</ul>
</li>
</ul>
</li>
<li>是否需要检索？<ul>
<li>完全不需要检索、排序、聚合分析的字段<ul>
<li>enabled设置为false</li>
</ul>
</li>
<li>不需要检索的字段<ul>
<li>index设置为false</li>
</ul>
</li>
<li>需要检索的字段，可以通过如下配置设定需要的存储粒度<ul>
<li>index_options结合需要设定</li>
<li>norms不需要归一化数据时关闭即可</li>
</ul>
</li>
</ul>
</li>
<li>是否需要排序和聚合分析？<ul>
<li>不需要排序或者聚合分析<ul>
<li>doc_values设置为false</li>
<li>fielddata设置为false</li>
</ul>
</li>
</ul>
</li>
<li>是否需要另行存储？<ul>
<li>是否需要专门存储当前字段的数据？<ul>
<li>store设定为true，即可存储该字段的原始内容（与_source中的不相关）</li>
<li>一般结合_source的enabled设定为false时使用</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="关联关系处理"><a href="#关联关系处理" class="headerlink" title="关联关系处理"></a>关联关系处理</h3><ul>
<li>ES不擅长处理关系型数据库中的关联关系，在ES中可以通过如下两种手段变相解决<ul>
<li>Nested Object</li>
<li>Parent/Child</li>
</ul>
</li>
</ul>
<h4 id="Nested-Object"><a href="#Nested-Object" class="headerlink" title="Nested Object"></a>Nested Object</h4><blockquote>
<p>在设置mapping的时候，type的值为nested</p>
<p>API示例： PUT blog_index  {“mappings”:{“doc”:{“_source”:{“enabled”:true},”properties”:{“title”:{“type”:”text”,”fields”:{“keyword”:{“type”:”keyword”}},”store”:true},”publish_date”:{“type”:”date”,”store”:true},”author”:{“type”:”keyword”,”store”:true},”abstract”:{“type”:”keyword”,”store”:true},”content”:{“type”:”text”,”store”:true},”url”:{“type”:”keyword”,”doc_values”:false,”norms”:false,”ignore_above”:100,”store”:true},”comments”:{“type”:”nested”,”properties”:{“username”:{“type”:”keyword”,”ignore_above”:100},”date”:{“type”:”date”},”content”:{“type”:”text”}}}}}}}</p>
</blockquote>
<h4 id="Parent-Child"><a href="#Parent-Child" class="headerlink" title="Parent/Child"></a>Parent/Child</h4><blockquote>
<p>ES还提供了类似关系型数据库中join的实现方式，使用join数据类型实现，6.x版本。指明父子关系类型</p>
<p>API示例：PUT blog_index_parent_child  {“mappings”:{“doc”:{“properties”:{“join”:{“type”:”join”,”relations”:{“blog”:”comments”}}}}}} </p>
<p>类型为join，关系relations中，左边为父类型名称，右边为子类型名称</p>
<p>在保存的时候，必须使得父子类型的数据在同一个shard上面</p>
</blockquote>
<ul>
<li>常见query关键词<ul>
<li>parent_id：返回某父文档的子文档</li>
<li>has_child：返回包含某子文档的父文档</li>
<li>has_parent：返回包含某父文档的子文档</li>
</ul>
</li>
</ul>
<h4 id="Nested-Object-vs-Parent-Child"><a href="#Nested-Object-vs-Parent-Child" class="headerlink" title="Nested Object vs Parent/Child"></a>Nested Object vs Parent/Child</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">Nested Object</th>
<th style="text-align:center">Parent/Child</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:center">文档存储在一起，因此可读性能高</td>
<td style="text-align:center">父子文档可以独立更新，互不影响</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">更新父或子文档时需要更新整个文档</td>
<td style="text-align:center">为了维护join的关系，需要占用部分内存，读取性能较差</td>
</tr>
<tr>
<td style="text-align:center">场景</td>
<td style="text-align:center">子文档偶尔更新，查询频繁</td>
<td style="text-align:center">子文档更新频繁</td>
</tr>
</tbody>
</table>
</div>
<p><strong>尽量选择Nested Object解决问题</strong></p>
<h3 id="reindex"><a href="#reindex" class="headerlink" title="reindex"></a>reindex</h3><ul>
<li>指重建所有数据的过程，一般发生在如下情况：<ul>
<li>mapping设置变更，比如字段类型变化、分词器字典更新等</li>
<li>index设置变更，比如分片更改等</li>
<li>迁移数据</li>
</ul>
</li>
<li>ES提供了现成的API用于完成该工作<ul>
<li>_update_by_query在现有索引上重建</li>
<li>_reindex在其他索引上重建</li>
<li>POST _reindex {“source”: {“index”: “spider”  }, “dest”: {“index”: “new_spider”,”op_type”: “create”}}</li>
</ul>
</li>
</ul>
<h2 id="集群调优建议"><a href="#集群调优建议" class="headerlink" title="集群调优建议"></a>集群调优建议</h2><h3 id="生成环境部署建议"><a href="#生成环境部署建议" class="headerlink" title="生成环境部署建议"></a>生成环境部署建议</h3><ul>
<li>遵照官方建议设置所有的系统参数</li>
<li>参见文档Setup ElasticSearch -&gt; Important System Configuration</li>
<li>容量预估<br>  磁盘总大小 = 源数据 <em> (1 + 副本数量) </em> (1 + 索引开销) / (1 - Linux预留空间) / (1 - ES开销) / (1 - 安全阈值) <pre><code>         = 源数据 * (1 + 副本数量) * 1.7
</code></pre></li>
<li>大文件参数设置</li>
<li>别名设置<h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3></li>
<li>Java环境</li>
<li>* - nofile 20480, 调整文件打开数</li>
<li>swap off,关闭swap</li>
<li>* - memlock unlimited, 调整memlock</li>
<li>ulimit -n 204800, 调整每个进程可打开文件数<h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3>vi /elasticsearch/bin/elasticsearch.sh<br>set ES_HEAP_SIZE=31G<blockquote>
<p>HEAP_SIZE 设置为物理内存的50%左右，其余剩下的内容留给操作系统做文件系统分页缓存，不要超过32G</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3></blockquote>
</li>
<li>client端减少频繁建立连接<ul>
<li>使用TCP长连接，而非HTTP</li>
</ul>
</li>
<li>client减少请求次数，合并索引操作<ul>
<li>使用bulk接口</li>
<li>合理增加bulk对列长度</li>
</ul>
</li>
<li>尽量减少索引大小，索引按日期滚动</li>
<li>写入数据不指定_id,让ES自动产生   </li>
</ul>
<h2 id="Java-API示例"><a href="#Java-API示例" class="headerlink" title="Java API示例"></a>Java API示例</h2><blockquote>
<p>如果使用的是spring-boot-starter-data-elasticsearch，则可以直接使用创建接口继承ElasticSearchRepository\<t, id>即可，不过高版本会有分页查询不准确的问题，同时分词需要另外配置，其中的增删改查直接使用接口提供的即可</t,></p>
<p>如果使用的是原生的ElasticSearch Java API操作，可以使用注入ElasticsearchTemplate，直接操作</p>
</blockquote>
<h1 id="相关课程和书籍"><a href="#相关课程和书籍" class="headerlink" title="相关课程和书籍"></a>相关课程和书籍</h1><blockquote>
<p><a href="http://coding.imooc.com/class/181.html" target="_blank" rel="noopener">Elastic Stack从入门到实践</a></p>
<p>《从Lucene到ElasticSearch全文检索实战》<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 
e=>end: 
op1=>operation: Character Filters
op2=>operation: Tokenizer
op3=>operation: Token Filters

st->op1->op2
op2->op3->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 
e=>end: 
op1=>operation: 对查询的语句分词，如alfred way
op2=>operation: 分词后为alfed和way
op3=>operation: 针对每一个词，然后根据username的倒排索引进行匹配算分。比如alfred文档列表为1,2。way的文档ID为1 算分模型TF/IDF、BM25
op4=>operation: 汇总得分
op5=>operation: 根据得分排序，返回匹配文档

st->op1->op2->op3->op4->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ElasticSearch/" rel="tag"># ElasticSearch</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/10/Design-Pattern/" rel="next" title="设计模式">
                <i class="fa fa-chevron-left"></i> 设计模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/03/concurrent/" rel="prev" title="concurrent">
                concurrent <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DeepRedApple</p>
              <p class="site-description motion-element" itemprop="description">不停的挖坑，不停的跳坑，不停的填坑</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">1.</span> <span class="nav-text">ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch入门"><span class="nav-number">1.1.</span> <span class="nav-text">ElasticSearch入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文档Document"><span class="nav-number">1.1.1.</span> <span class="nav-text">文档Document</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">元数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引Index"><span class="nav-number">1.1.2.</span> <span class="nav-text">索引Index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点Node"><span class="nav-number">1.1.3.</span> <span class="nav-text">节点Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群Cluster"><span class="nav-number">1.1.4.</span> <span class="nav-text">集群Cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rest-API"><span class="nav-number">1.1.5.</span> <span class="nav-text">Rest API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引API"><span class="nav-number">1.1.6.</span> <span class="nav-text">索引API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档Document-API"><span class="nav-number">1.1.7.</span> <span class="nav-text">文档Document API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#倒排索引和分词"><span class="nav-number">1.2.</span> <span class="nav-text">倒排索引和分词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正排索引"><span class="nav-number">1.2.1.</span> <span class="nav-text">正排索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒排索引"><span class="nav-number">1.2.2.</span> <span class="nav-text">倒排索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#详解"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">详解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分词"><span class="nav-number">1.2.3.</span> <span class="nav-text">分词</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分词器"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">分词器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义分词"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">自定义分词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Character-Filter"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">Character Filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tokenizer"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">Tokenizer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Token-Filter"><span class="nav-number">1.2.3.2.3.</span> <span class="nav-text">Token Filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#API操作"><span class="nav-number">1.2.3.2.4.</span> <span class="nav-text">API操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分词使用说明"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">分词使用说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Analyze-API"><span class="nav-number">1.2.4.</span> <span class="nav-text">Analyze API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mapping"><span class="nav-number">1.3.</span> <span class="nav-text">Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义Mapping"><span class="nav-number">1.3.1.</span> <span class="nav-text">自定义Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#建议"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Mapping"><span class="nav-number">1.3.3.</span> <span class="nav-text">Dynamic Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#日期与数字识别"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">日期与数字识别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamic-Templates"><span class="nav-number">1.3.4.</span> <span class="nav-text">Dynamic Templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引模版"><span class="nav-number">1.3.5.</span> <span class="nav-text">索引模版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-API"><span class="nav-number">1.4.</span> <span class="nav-text">Search API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#URI-Search"><span class="nav-number">1.4.1.</span> <span class="nav-text">URI Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Query-String-Syntax"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Query String Syntax</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-Body-Search"><span class="nav-number">1.4.2.</span> <span class="nav-text">Request Body Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Query-DSL"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Query DSL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段类查询"><span class="nav-number">1.4.3.</span> <span class="nav-text">字段类查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Match-Query"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Match Query</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#相关性算分"><span class="nav-number">1.4.3.1.1.</span> <span class="nav-text">相关性算分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念"><span class="nav-number">1.4.3.1.1.1.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Match-Phrase-Query"><span class="nav-number">1.4.3.1.2.</span> <span class="nav-text">Match Phrase Query</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Query-String-Query"><span class="nav-number">1.4.3.1.3.</span> <span class="nav-text">Query String Query</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Simple-Query-String-Query"><span class="nav-number">1.4.3.1.4.</span> <span class="nav-text">Simple Query String Query</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Term-Query"><span class="nav-number">1.4.3.1.5.</span> <span class="nav-text">Term Query</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Terms-Query"><span class="nav-number">1.4.3.1.6.</span> <span class="nav-text">Terms Query</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Range-Query"><span class="nav-number">1.4.3.1.7.</span> <span class="nav-text">Range Query</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复合查询"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">复合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bool-query"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">Bool query</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Filter"><span class="nav-number">1.4.3.2.1.1.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Must"><span class="nav-number">1.4.3.2.1.2.</span> <span class="nav-text">Must</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Must-not"><span class="nav-number">1.4.3.2.1.3.</span> <span class="nav-text">Must not</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Should"><span class="nav-number">1.4.3.2.1.4.</span> <span class="nav-text">Should</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Query-Context-VS-Filter-Context"><span class="nav-number">1.4.3.2.1.5.</span> <span class="nav-text">Query Context VS Filter Context</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Count-API"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Count API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Source-Filtering"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Source Filtering</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式特性介绍"><span class="nav-number">1.5.</span> <span class="nav-text">分布式特性介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cerebro安装与运行"><span class="nav-number">1.5.1.</span> <span class="nav-text">cerebro安装与运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建集群"><span class="nav-number">1.5.2.</span> <span class="nav-text">构建集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#副本与分片"><span class="nav-number">1.5.3.</span> <span class="nav-text">副本与分片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#提高系统可用性"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">提高系统可用性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增大系统容量"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">增大系统容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片问题"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">分片问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群状态"><span class="nav-number">1.5.4.</span> <span class="nav-text">集群状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移"><span class="nav-number">1.5.5.</span> <span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档分布式存储"><span class="nav-number">1.5.6.</span> <span class="nav-text">文档分布式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#脑裂问题"><span class="nav-number">1.5.7.</span> <span class="nav-text">脑裂问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shard详解"><span class="nav-number">1.5.8.</span> <span class="nav-text">Shard详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search的运行机制"><span class="nav-number">1.6.</span> <span class="nav-text">Search的运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Query-Then-Fetch"><span class="nav-number">1.6.1.</span> <span class="nav-text">Query Then Fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关性算分-1"><span class="nav-number">1.6.2.</span> <span class="nav-text">相关性算分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">1.6.3.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fielddata"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">Fielddata</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Doc-Values"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">Doc Values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docvalues-fields"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">docvalues_fields</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页和遍历"><span class="nav-number">1.6.4.</span> <span class="nav-text">分页和遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#from-size"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">from/size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scroll"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">Scroll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Search-after"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">Search_after</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合分析"><span class="nav-number">1.7.</span> <span class="nav-text">聚合分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Metric聚合分析"><span class="nav-number">1.7.1.</span> <span class="nav-text">Metric聚合分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bucket聚合分析"><span class="nav-number">1.7.2.</span> <span class="nav-text">Bucket聚合分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bucket-Metric聚合分析"><span class="nav-number">1.7.3.</span> <span class="nav-text">Bucket + Metric聚合分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipeline聚合分析"><span class="nav-number">1.7.4.</span> <span class="nav-text">Pipeline聚合分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用范围"><span class="nav-number">1.7.5.</span> <span class="nav-text">作用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序-1"><span class="nav-number">1.7.6.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理和精准度问题"><span class="nav-number">1.7.7.</span> <span class="nav-text">原理和精准度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#近似统计算法"><span class="nav-number">1.7.8.</span> <span class="nav-text">近似统计算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据建模"><span class="nav-number">1.8.</span> <span class="nav-text">数据建模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES中的数据建模"><span class="nav-number">1.8.1.</span> <span class="nav-text">ES中的数据建模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联关系处理"><span class="nav-number">1.8.2.</span> <span class="nav-text">关联关系处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Nested-Object"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">Nested Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parent-Child"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">Parent/Child</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nested-Object-vs-Parent-Child"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">Nested Object vs Parent/Child</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reindex"><span class="nav-number">1.8.3.</span> <span class="nav-text">reindex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群调优建议"><span class="nav-number">1.9.</span> <span class="nav-text">集群调优建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成环境部署建议"><span class="nav-number">1.9.1.</span> <span class="nav-text">生成环境部署建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器优化"><span class="nav-number">1.9.2.</span> <span class="nav-text">服务器优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM参数"><span class="nav-number">1.9.3.</span> <span class="nav-text">JVM参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引优化"><span class="nav-number">1.9.4.</span> <span class="nav-text">索引优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-API示例"><span class="nav-number">1.10.</span> <span class="nav-text">Java API示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关课程和书籍"><span class="nav-number">2.</span> <span class="nav-text">相关课程和书籍</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DeepRedApple</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '9iOMi2aVJGa6mM22fGUYDAvQ-gzGzoHsz',
        appKey: 'VpHSngxnKJSv6FDHpsXzBPxR',
        placeholder: '来啊，互相伤害啊，各位大佬们！！！',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
